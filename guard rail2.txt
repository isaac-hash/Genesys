[
  {
    "pain_point": "Verbose and Redundant Configuration & Low-Level Communication Overhead",
    "concept": "Too much repeated setup between code and config; communication primitives require boilerplate.",
    "details": {
      "issue": "ROS 2 requires verbose launch files, repetitive setup of publishers/subscribers, and manual registration of nodes.",
      "solution": "A hybrid abstraction: decorators simplify node and comms setup in code, while a YAML configuration provides declarative wiring and parameters. The framework auto-generates ROS 2 launch files and configuration from these abstractions, allowing `framework run` and `framework launch` to be a single command.",
      "compatibility_rule": "The framework's auto-generated launch files and configuration must be compatible with standard ROS 2 tools and conventions."
    }
  },
  {
    "pain_point": "Fragile and Complex Simulation Setup",
    "concept": "It is difficult to set up, launch, and control a robot in a simulation environment.",
    "details": {
      "issue": "Requires manual creation of world files, robot spawning launch files, and complex environment variable management to get a simulation running.",
      "solution": "The framework provides a unified command to launch a pre-configured simulation with a robot model, world file, and control nodes. It abstracts away the need for separate launch files for spawning the robot and controlling the simulation.",
      "compatibility_rule": "The framework's simulation integration must work seamlessly with standard ROS 2 simulation tools (e.g., Gazebo, Ignition), without requiring user-specific configuration of the underlying tools."
    }
  },
  {
    "pain_point": "Manual Launch File Creation and Maintenance",
    "concept": "Developers manually create and update verbose launch files.",
    "details": {
      "issue": "ROS 2 launch files can be complex, especially for large systems with many nodes, parameters, and remappings. Maintaining these files as the system evolves is a manual and error-prone process.",
      "solution": "The framework automatically generates a launch file for each package, which includes all nodes decorated with `@node` and automatically loads associated YAML configuration files. The `framework launch` command then uses this auto-generated file, eliminating manual launch file creation.",
      "compatibility_rule": "The auto-generated launch file for a package must be named `<pkg_name>_launch.py` and must be placed in a `launch/` directory at the package root to remain consistent with ROS 2 best practices."
    }
  },
  {
    "use_case": "Launching a specific node or launch file",
    "command": "framework launch <package_name>:<launch_file>",
    "explanation": "This command serves two purposes: launching a specific launch file by name or, if no launch file is specified, launching the auto-generated launch file for the package. It handles all sourcing and path resolution automatically.",
    "subcommands": [
      {
        "command": "framework launch <pkg_name>:<launch_file>",
        "details": "Launches a specific launch file by name. The CLI resolves the path `src/<pkg_name>/launch/<launch_file>`.",
        "example": "framework launch my_robot_pkg:robot_with_rviz.py"
      },
      {
        "command": "framework launch <pkg_name>",
        "details": "Launches the auto-generated launch file for the specified package. The CLI resolves the path `src/<pkg_name>/launch/<pkg_name>_launch.py`.",
        "example": "framework launch my_robot_pkg"
      }
    ],
    "implementation_notes": {
      "automation_steps": [
        "Sourcing: Automatically sources the ROS 2 and workspace `setup.bash` environments.",
        "Path Resolution: Resolves the launch file path from the package name.",
        "Command Execution: Executes `ros2 launch <package_name> <launch_file>` as a subprocess."
      ],
      "error_handling": "Prints an error if the specified package or launch file does not exist."
    }
  },
  {
    "use_case": "Launching a robot in a simulation",
    "command": "framework sim <world_file>",
    "explanation": "This command launches a simulation environment (e.g., Gazebo) with a specific world and the robot model for the active package. It abstracts away the complex process of creating and executing simulation-specific launch files.",
    "subcommands": [
      {
        "command": "framework sim <world_file>",
        "details": "Launches a simulation using the specified world file. A launch file is auto-generated in memory (or a temporary file) to spawn the robot model and any associated control nodes.",
        "example": "framework sim empty.world"
      }
    ],
    "implementation_notes": {
      "automation_steps": [
        "Sourcing: Automatically sources the ROS 2 and workspace `setup.bash` environments.",
        "World Resolution: Resolves the path to the world file from a `sim/worlds` directory.",
        "Launch File Generation: Auto-generates a temporary launch file with the following actions: 1. Start the simulation engine. 2. Load the world file. 3. Spawn the robot model. 4. Run all registered nodes from the current package.",
        "Command Execution: Executes `ros2 launch <temp_launch_file>` as a subprocess."
      ],
      "error_handling": "Prints an error if the specified world file is not found."
    }
  }
]
