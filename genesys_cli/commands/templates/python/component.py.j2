from genesys.decorators import component, {% if component_type == 'publisher' %}publisher{% elif component_type == 'subscriber' %}subscriber{% elif component_type == 'service' %}service{% elif component_type == 'actionserver' %}action_server{% elif component_type == 'lifecycle' %}lifecycle_node{% endif %}

from rclpy.node import Node

{% if component_type == 'publisher' or component_type == 'subscriber' %}from std_msgs.msg import String{% endif %}
{% if component_type == 'actionserver' %}from example_interfaces.action import Fibonacci{% endif %}
{% if component_type == 'service' %}from example_interfaces.srv import AddTwoInts{% endif %}

from rclpy_components.node_factory import NodeFactory
from genesys.node_base import NodeBase
{% if component_type == 'lifecycle' %}from rclpy.lifecycle import State, TransitionCallbackReturn{% endif %}

@component("{{ node_name }}")
class {{ class_name }}(NodeBase):
    """
    A simple {{ component_type }} component.
    This component is auto-generated by the Genesys framework.
    """
    def __init__(self, *args, **kwargs):
        super().__init__("{{ node_name }}", self)
        # The logger is automatically available after super().__init__
        self.get_logger().info("{{ class_name }} component initialized.")
        {% if component_type == 'publisher' %}self.counter = 0{% endif %}
        {% if component_type == 'actionserver' %}self._action_server = None{% endif %}

    {% if component_type == 'publisher' %}
    @publisher(topic="chatter", msg_type=String)
    def publish_message(self):
        """
        This method is executed periodically (e.g., by a timer).
        The String object it returns is automatically published to the 'chatter' topic.
        """
        msg = String()
        msg.data = f"Hello from {{ class_name }}! Message #{self.counter + 1}"
        self.get_logger().info(f"Publishing: {msg.data}")
        self.counter += 1
        return msg
    {% elif component_type == 'subscriber' %}
    @subscriber(topic="chatter", msg_type=String)
    def message_callback(self, msg):
        """
        This method is executed whenever a message is received on the 'chatter' topic.
        """
        self.get_logger().info(f'I heard: "{msg.data}"')
    {% elif component_type == 'service' %}
    @service(service_name="add_two_ints", service_type=AddTwoInts)
    def add_two_ints_callback(self, request, response):
        """
        This method is executed when the 'add_two_ints' service is called.
        """
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: {request.a} + {request.b}')
        return response
    {% elif component_type == 'actionserver' %}
    @action_server(action_name="fibonacci", action_type=Fibonacci)
    def fibonacci_callback(self, goal_handle):
        """
        This method is executed when the 'fibonacci' action server receives a goal.
        """
        self.get_logger().info(f'Received goal: {goal_handle.request.order}')
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            feedback_msg.sequence.append(feedback_msg.sequence[i] + feedback_msg.sequence[i-1])
            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')
            goal_handle.publish_feedback(feedback_msg)
            # Simulate work
            # time.sleep(1)

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info(f'Goal succeeded. Result: {result.sequence}')
        return result
    {% elif component_type == 'lifecycle' %}
    # Lifecycle node callbacks
    def on_configure(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info("on_configure() is called.")
        # Initialize publishers, subscribers, etc. here
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info("on_activate() is called.")
        # Activate publishers, subscribers, etc. here
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info("on_deactivate() is called.")
        # Deactivate publishers, subscribers, etc. here
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info("on_cleanup() is called.")
        # Destroy publishers, subscribers, etc. here
        return TransitionCallbackReturn.SUCCESS

    def on_shutdown(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info("on_shutdown() is called.")
        # Perform final cleanup
        return TransitionCallbackReturn.SUCCESS
    {% endif %}

def get_node_factory():
    return NodeFactory({{ class_name }})