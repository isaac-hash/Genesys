
from genesys.decorators import node, lifecycle_node, timer, publisher
from genesys.helpers import spin_node
from rclpy.lifecycle import TransitionCallbackReturn
from std_msgs.msg import String

@lifecycle_node
@node("{{ node_name }}")
class {{ class_name }}:
    """
    A simple lifecycle node.
    This node is auto-generated by the Genesys framework.
    It must be managed by a lifecycle manager to transition through its states.
    """
    def __init__(self):
        self.counter = 0
        self.logger.info("Lifecycle node created. In 'unconfigured' state.")

    # --- Lifecycle Hooks ---
    def on_configure(self, state):
        self.logger.info("on_configure() is called. Setting up resources.")
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state):
        self.logger.info("on_activate() is called. Activating the node.")
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state):
        self.logger.info("on_deactivate() is called. Deactivating the node.")
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state):
        self.logger.info("on_cleanup() is called. Cleaning up resources.")
        return TransitionCallbackReturn.SUCCESS
    
    def on_shutdown(self, state):
        self.logger.info("on_shutdown() is called. Shutting down.")
        return TransitionCallbackReturn.SUCCESS

    # --- Business Logic ---
    @timer(period_sec=1.0)
    @publisher(topic="lifecycle_chatter", msg_type=String)
    def publish_message(self):
        """
        This timer and publisher will only be active when the node is in the 'active' state.
        """
        msg = String()
        msg.data = f"Hello from Lifecycle Node! Message #{{self.counter}}"
        
        self.logger.info(f'Publishing: "{{msg.data}}"')
        self.counter += 1
        
        return msg
