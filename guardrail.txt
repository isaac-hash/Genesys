{
  "name": "Genesys Component Integration Guardrail",
  "version": "1.0",
  "purpose": "Add first-class Python composable node support to Genesys and build a genesys pipeline system on top of composition.",
  "assumptions": {
    "ros2_distribution": "humble+ (or later)",
    "python_version": "3.8+",
    "packaging": "setuptools / setup.py based Python packages",
    "genesys_architecture": "decorator-based node generation that auto-registers console_scripts entries",
    "existing_decorators": [
      "@node",
      "@publisher",
      "@subscriber",
      "@timer",
      "@service",
      "@action_server",
      "@lifecycle"
    ]
  },
  "prerequisites": [
    "rclpy components package available: rclpy_components",
    "colcon build environment",
    "genesys CLI codebase editable",
    "unit test framework (pytest)",
    "CI runner with ROS2 environment for integration tests"
  ],
  "high_level_components": [
    "genesys.decorators.component (new)",
    "genesys.codegen (template generator updates)",
    "genesys.installer (setup.py / packaging updates)",
    "genesys.cli (new commands: make:component, pipeline create/run/watch)",
    "genesys.pipeline (pipeline DSL, YAML format, launch generator)",
    "tests.unit and tests.integration",
    "documentation and migration guide"
  ],
  "guardrails_and_constraints": {
    "compatibility": "All existing Genesys generated regular nodes must continue to work (console_scripts). Component support must be additive.",
    "safety": "No decorator should call rclpy.init() or rclpy.spin() implicitly when used as a component. The spin helper remains available for standalone executables.",
    "entrypoint_separation": "console_scripts and rclpy_components entry groups are separate and both may exist for the same source file.",
    "error_handling": "Component loading failures must be logged and not crash the container; provide descriptive exceptions and error codes.",
    "language_mixing": "Allow both Python and C++ components in same container; ensure plugin name resolution follows package.plugin conventions.",
    "hot_reload": "Support hot unload/load in dev mode, but require explicit user opt-in for production."
  },
  "implementation_steps": [
    {
      "step": 1,
      "title": "Add @component decorator to genesys.decorators",
      "description": "Create a decorator that marks classes as components, records metadata, and auto-generates a minimal get_node_factory staticmethod. The decorator must not perform any runtime initialization.",
      "files": [
        "genesys/decorators.py"
      ],
      "actions": [
        "Implement function component(name: Optional[str] = None, **meta) returning wrapper",
        "Wrapper should attach: __genesys_is_component__ = True and __genesys_component_name__",
        "Wrapper should attach a staticmethod get_node_factory() that returns NodeFactory(class)",
        "Decorator must preserve other Genesys metadata (publishers/subscribers/timers) by not overwriting them"
      ],
      "example_code": "def component(name=None, **meta):\n    def wrapper(cls):\n        comp_name = name or getattr(cls, '__name__').lower()\n        cls.__genesys_is_component__ = True\n        cls.__genesys_component_name__ = comp_name\n\n        def get_node_factory():\n            from rclpy_components import NodeFactory\n            return NodeFactory(cls)\n\n        cls.get_node_factory = staticmethod(get_node_factory)\n        # preserve existing genesys attributes\n        return cls\n    return wrapper"
    },
    {
      "step": 2,
      "title": "Ensure existing pub/sub/timer decorators attach metadata only",
      "description": "Verify that @publisher, @subscriber, @timer, etc. only register metadata on the class and do not call node runtime functions. If any decorator performs runtime calls, refactor it to store metadata and perform wiring at node init-time.",
      "files": [
        "genesys/decorators.py",
        "genesys/runtime.py"
      ],
      "actions": [
        "Audit each decorator to ensure it appends metadata to cls.__genesys_publishers__ / __genesys_subscribers__ / __genesys_timers__ lists",
        "If wiring code exists, move wiring into a class mixin or Genesys base Node class __init__"
      ],
      "validation": "Unit tests that use decorators in a class but do not call spin helper should pass without invoking rclpy.init()."
    },
    {
      "step": 3,
      "title": "Modify Genesys codegen to generate get_node_factory() when component detected",
      "description": "When user creates a node via genesys make:node or make:component, generate get_node_factory() and a minimal staticmethod in the node source when the class is marked as a component. Keep existing main() generation for regular nodes.",
      "files": [
        "genesys/templates/node_template.py",
        "genesys/templates/component_template.py",
        "genesys/codegen.py"
      ],
      "actions": [
        "Add new template component_template.py that includes class def plus get_node_factory staticmethod",
        "Update codegen to choose the template based on user flag or decorator presence",
        "Add fallback: if class has __genesys_is_component__ True, inject get_node_factory if missing"
      ],
      "example_component_template": "from rclpy.node import Node\nfrom rclpy_components import NodeFactory\n\n@component('example')\nclass ExampleComponent(Node):\n    def __init__(self):\n        super().__init__('example')\n        # wiring: iterate metadata to create publishers/subscribers/timers\n\n    # user methods ...\n\ndef get_node_factory():\n    return NodeFactory(ExampleComponent)"
    },
    {
      "step": 4,
      "title": "Installer / packaging: add rclpy_components entry point generation",
      "description": "Modify packaging generator (setup.py builder) to automatically add both console_scripts and rclpy_components entry points when appropriate. Provide a combined entry_points dict.",
      "files": [
        "genesys/installer.py",
        "setup.py (generated by genesys)"
      ],
      "actions": [
        "When node is regular: add 'console_scripts': ['name = module:main']",
        "When node is a component: add 'rclpy_components': ['name = module:get_node_factory']",
        "When same file supports both, produce both entry groups in a single setup.py"
      ],
      "example_entry_points": "entry_points={\n    'console_scripts': [\n        'my_node = my_pkg.my_node:main'\n    ],\n    'rclpy_components': [\n        'my_component = my_pkg.my_component:get_node_factory'\n    ]\n}"
    },
    {
      "step": 5,
      "title": "Refactor Genesys runtime wiring to support component init-time wiring",
      "description": "Provide a helper that, during Node.__init__, reads genesys metadata and sets up publishers, subscribers, timers, and services. This wiring must work identically for regular and component classes.",
      "files": [
        "genesys/runtime.py",
        "genesys/node_base.py"
      ],
      "actions": [
        "Create NodeBase class that extends rclpy.node.Node and in __init__ executes Genesys metadata wiring logic",
        "Ensure this NodeBase is inherited (or composition applied) by generated classes so metadata wiring is executed at node instantiation (container load time)",
        "Ensure no rclpy.init/spin calls exist in wiring"
      ],
      "example_wiring": "class NodeBase(Node):\n    def __init__(self, name):\n        super().__init__(name)\n        # read __genesys_publishers__ etc and create publishers/subscribers/timers"
    },
    {
      "step": 6,
      "title": "Add CLI generators: genesys make:component and genesys make:node --component",
      "description": "Extend the Genesys CLI so users can explicitly request a component scaffold or toggle component behavior in the generator.",
      "files": [
        "genesys/cli.py"
      ],
      "actions": [
        "Add command 'genesys make:component <name>' that uses component template",
        "Add optional flag '--component' on make:node to produce both main() and get_node_factory() or only get_node_factory() based on user choice",
        "Add help text that explains differences"
      ],
      "examples": [
        "genesys make:component gray_filter",
        "genesys make:node camera --component"
      ]
    },
    {
      "step": 7,
      "title": "Launch templates & mixing nodes: implement generator for mixed launch files",
      "description": "Provide Launch generator helpers and example templates that include both Node (regular) and ComposableNodeContainer (components) and optionally a LoadComposableNodes action.",
      "files": [
        "genesys/templates/launch/mixed_launch.py",
        "genesys/launch_generators.py"
      ],
      "actions": [
        "Create canonical launch templates showing: Node (regular), ComposableNodeContainer, LoadComposableNodes or direct ComposableNodeContainer composable_node_descriptions",
        "Support remapping and parameter injection for both regular executables and components",
        "Provide helper for automatic remap of topics when wiring pipeline"
      ],
      "example_launch_snippet": "from launch import LaunchDescription\nfrom launch_ros.actions import Node, ComposableNodeContainer\nfrom launch_ros.descriptions import ComposableNode\n\ndef generate_launch_description():\n    regular = Node(package='pkg', executable='regular_exec', name='regular')\n    container = ComposableNodeContainer(\n        name='container', package='rclpy_components', executable='component_container',\n        composable_node_descriptions=[\n            ComposableNode(package='pkg', plugin='gray_filter', name='gray_filter')\n        ], output='screen')\n    return LaunchDescription([regular, container])"
    },
    {
      "step": 8,
      "title": "genesys pipeline DSL + YAML format",
      "description": "Design the pipeline DSL and YAML schema, plus a generator that turns pipeline definitions into launch files and optional runtime orchestration code.",
      "files": [
        "genesys/pipeline/schema.yaml",
        "genesys/pipeline/parser.py",
        "genesys/pipeline/generator.py"
      ],
      "actions": [
        "Define YAML schema (pipeline: ordered list or DAG, nodes: name, package, plugin, remaps, qos, params)",
        "Implement parser that validates DAG, detects cycles, validates node availability (entry points exist), and resolves remaps",
        "Implement generator that outputs a ComposableNodeContainer launch file and optional Node launch entries for regular nodes"
      ],
      "example_yaml": "pipeline:\n  name: vision\n  nodes:\n    - id: camera\n      package: my_pkg\n      plugin: camera\n      publish: raw_image\n    - id: gray_filter\n      package: my_pkg\n      plugin: gray_filter\n      subscribe: raw_image\n      publish: gray_image\n    - id: edge_detector\n      package: my_pkg\n      plugin: edge_detector\n      subscribe: gray_image\n      publish: edges"
    },
    {
      "step": 9,
      "title": "genesys CLI: add pipeline commands",
      "description": "Add 'genesys pipeline create/run/watch' commands that integrate with the pipeline generator and ROS2 launch system.",
      "files": [
        "genesys/cli.py"
      ],
      "actions": [
        "genesys pipeline create <name> (scaffold YAML and example components)",
        "genesys pipeline run <name> (generate launch and call ros2 launch)",
        "genesys pipeline watch <name> (monitor component container and automatically reload changed components)"
      ],
      "notes": "Watch mode must be opt-in and suitable for development only; include file-change debounce and safe reload logic"
    },
    {
      "step": 10,
      "title": "Testing strategy (unit + integration)",
      "description": "Implement unit tests for decorators and codegen and integration tests for launch and pipeline behavior.",
      "files": [
        "tests/unit/test_decorators.py",
        "tests/unit/test_codegen.py",
        "tests/integration/test_launch_mixed.py",
        "tests/integration/test_pipeline_run.py"
      ],
      "actions": [
        "Unit tests: ensure that using @component with @publisher/@subscriber only sets metadata and does not call rclpy.init()",
        "Integration tests: build package, source install/setup.bash, launch mixed launch file (use rostest or launch testing) and assert topics communicate",
        "Add tests for packaging: verify setup.py contains correct entry points for both console_scripts and rclpy_components"
      ],
      "example_tests": "def test_component_metadata():\n    @component('foo')\n    class Foo:\n        @publisher('out', String)\n        def p(self):\n            return String()\n    assert getattr(Foo, '__genesys_is_component__') is True"
    },
    {
      "step": 11,
      "title": "CI/CD integration",
      "description": "Add CI pipeline stages to run unit tests, build packages, and run a subset of integration tests on ROS2 CI runners or containerized ROS2 images.",
      "files": [
        ".github/workflows/ci.yml"
      ],
      "actions": [
        "Unit test stage (python/pylint/pytest)",
        "Build stage (colcon build inside ROS2 docker image)",
        "Integration stage (run launch tests in containerized runner; optional due to cost)",
        "Package publishing stage (if required) only on release tags"
      ]
    },
    {
      "step": 12,
      "title": "Documentation and examples",
      "description": "Update docs with migration guide, examples, and recipes and provide a quickstart: component, mixed launch, pipeline run.",
      "files": [
        "docs/components.md",
        "docs/pipeline.md",
        "examples/vision_pipeline/"
      ],
      "actions": [
        "Document @component behavior and show conversion recipes from existing Genesys nodes to components",
        "Add code examples for mixed launch files and pipelines",
        "Add troubleshooting section (common component load errors, permission, missing entry points)"
      ]
    },
    {
      "step": 13,
      "title": "Migration guide and backwards compatibility",
      "description": "Provide clear migration steps for existing repos generated by Genesys that want to add component support.",
      "files": [
        "docs/migration.md"
      ],
      "actions": [
        "Show minimal patch: add @component decorator; add get_node_factory() if generator cannot inject automatically; add rclpy_components entry in setup.py",
        "Provide script to scan repos for @node classes and optionally inject get_node_factory stubs"
      ],
      "example_migration_snippet": "def get_node_factory():\n    from rclpy_components import NodeFactory\n    return NodeFactory(ExistingClass)"
    }
  ],
  "runtime_behavior_spec": {
    "component_class_contract": "Classes decorated with @component must be proper rclpy Node subclasses or Genesys NodeBase subclasses that run initialization logic in __init__ only. They must not call rclpy.init or rclpy.spin.",
    "get_node_factory_contract": "get_node_factory() must return an instance of rclpy_components.NodeFactory or behave as a factory function for the container. It must not call spin or init.",
    "packaging_contract": "setup.py must list 'rclpy_components' entry points for components. When both entry groups exist, both should be present.",
    "launch_contract": "Composable nodes loaded into a component_container should not depend on process-level global state. Any global resources must be guarded or provided by the container at startup."
  },
  "error_handling_and_observability": {
    "component_load_failure": {
      "log_level": "ERROR",
      "message": "Detailed failure including traceback, expected entry point, and package path",
      "recovery": "If an optional component fails during container start, continue launching other components; provide 'fail_fast' pipeline option to stop on first failure"
    },
    "diagnostics": [
      "Each component should declare ROS diagnostics topic for health (optional)",
      "genesys pipeline manager should expose an HTTP or ROS-topic status endpoint listing loaded components, version, uptime, and last error"
    ],
    "metrics": [
      "Expose per-component CPU and memory usage via /genesys/metrics or integrate with Prometheus exporters"
    ]
  },
  "security_and_permissions": {
    "code_execution": "Only load components from trusted packages. Warn users if loading from untrusted sources.",
    "package_signing": "Recommend using signed packages in production for auto-load pipelines.",
    "sandboxing": "Recommend using OS-level sandboxing/containers when running third-party components."
  },
  "performance_considerations": {
    "python_intra_process": "Note: Python composable nodes do NOT get C++ zero-copy intra-process transport. Document this clearly and recommend C++ for highest bandwidth components.",
    "container_sizing": "Provide recommended container instance sizing heuristics for typical pipelines (number of components, CPU-bound vs IO-bound)",
    "profiling": "Include a genesys profiler integration that can attach to a component container and report latency per topic callback"
  },
  "example_concrete_files_to_generate": [
    {
      "path": "my_pkg/src/my_pkg/gray_filter.py",
      "content_snippet": "from genesys.decorators import component, subscriber, publisher\nfrom sensor_msgs.msg import Image\nfrom genesys.runtime import NodeBase\n\n@component('gray_filter')\nclass GrayFilter(NodeBase):\n    def __init__(self):\n        super().__init__('gray_filter')\n        # wiring performed by NodeBase using metadata\n\n    @subscriber('raw_image', Image)\n    def on_raw(self, msg):\n        # process and publish\n        self.publish('gray_image', out_msg)"
    },
    {
      "path": "my_pkg/setup.py",
      "content_snippet": "entry_points = {\n    'console_scripts': [\n        'motor_control = my_pkg.motor:main'\n    ],\n    'rclpy_components': [\n        'gray_filter = my_pkg.gray_filter:get_node_factory'\n    ]\n}"
    },
    {
      "path": "genesys/pipelines/vision.yaml",
      "content_snippet": "pipeline:\n  name: vision\n  nodes:\n    - id: camera\n      package: my_pkg\n      plugin: camera\n    - id: gray_filter\n      package: my_pkg\n      plugin: gray_filter\n"
    },
    {
      "path": "genesys/pipelines/vision.launch.py",
      "content_snippet": "from launch import LaunchDescription\nfrom launch_ros.actions import ComposableNodeContainer\nfrom launch_ros.descriptions import ComposableNode\n\ndef generate_launch_description():\n    nodes = [\n        ComposableNode(package='my_pkg', plugin='camera', name='camera'),\n        ComposableNode(package='my_pkg', plugin='gray_filter', name='gray_filter')\n    ]\n    container = ComposableNodeContainer(name='vision_container', package='rclpy_components', executable='component_container', composable_node_descriptions=nodes, output='screen')\n    return LaunchDescription([container])"
    }
  ],
  "acceptance_criteria": {
    "unit_tests": "All unit tests pass; tests cover decorator metadata only and injection logic",
    "integration_tests": "At least one mixed launch (regular + component container) communicates a topic end-to-end",
    "packaging_tests": "setup.py contains both entry groups when requested",
    "documentation": "docs/components.md and docs/pipeline.md published with examples",
    "backwards_compat": "Existing Genesys projects with no changes continue to run as before"
  },
  "next_steps_and_estimates": {
    "next_actions": [
      "Implement the @component decorator (step 1) and unit tests",
      "Modify codegen to generate component templates (step 3)",
      "Add packaging changes (step 4) and run a smoke integration test"
    ],
    "development_notes": "Follow TDD: write unit tests for each decorator change before modifying production code. Use feature branch 'feature/components' and open PR with incremental commits."
  }
}
