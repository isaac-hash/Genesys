[
  {
    "pain_point": "Complex Build and Package System",
    "concept": "Developers face too much boilerplate and a fragile multi-step build process.",
    "details": {
      "issue": "Manual creation of boilerplate files (package.xml, CMakeLists.txt, setup.py) and a multi-step, error-prone build process with colcon and sourcing.",
      "solution": "A unified CLI automates package creation and builds. It prompts the user to choose a build language (Python or C++), auto-generates the correct build files, and allows dependencies to be declared interactively. Inter-package dependencies are auto-registered in package.xml and build scripts so they are immediately available.",
      "compatibility_rule": "All generated projects must remain ROS 2–compatible and runnable with plain `colcon build` and `ros2 run`. The framework only adds automation and wrappers, never breaks underlying ROS 2 conventions."
    }
  },
  {
    "pain_point": "Verbose and Redundant Configuration & Low-Level Communication Overhead",
    "concept": "Too much repeated setup between code and config; communication primitives require boilerplate.",
    "details": {
      "issue": "ROS 2 requires verbose launch files, repetitive setup of publishers/subscribers, and manual registration of nodes.",
      "solution": "A hybrid abstraction: decorators simplify node and comms setup in code, while a YAML configuration provides declarative wiring and parameters. The framework auto-generates ROS 2 launch files behind the scenes, ensures new nodes are auto-registered, and makes them executable upon creation — so developers can run them immediately without extra steps.",
      "decorators": {
        "where_they_live": "Decorators are shipped with the framework CLI in a bundled package (e.g., framework_core/decorators.py for Python, framework_core_cpp/decorators.hpp for C++).",
        "how_they_are_used": "Users import them in their code via `from framework.decorators import node, publisher, subscriber`. They never edit the decorators themselves.",
        "distribution": "The decorators are installed alongside the CLI (via pip or similar). Every project automatically has access without extra setup.",
        "why_this_design": "Ensures consistency across all projects, allows framework upgrades to enhance decorators, and enables the CLI to scan decorators to auto-generate launch files, configs, and executables.",
        "compatibility_rule": "Decorators are syntactic sugar on top of ROS 2 APIs; under the hood, they expand to standard rclcpp/rclpy code so decorated nodes are still valid ROS 2 nodes."
      }
    }
  },
  {
    "pain_point": "Manual Sourcing of Setup Scripts and Entry Point Configuration",
    "concept": "ROS 2 requires developers to manually source multiple setup scripts and configure entry points to run nodes, leading to confusion and wasted time.",
    "details": {
      "issue": {
        "sourcing": [
          "Developers must manually source ROS 2 distro setup (e.g., /opt/ros/humble/setup.bash).",
          "They must also source the workspace’s install/setup.bash after every build.",
          "Different shells (bash, zsh, ps1) require different scripts (setup.ps1, local_setup.zsh, etc.).",
          "For colcon builds with --symlink-install, sourcing must be repeated or scripted."
        ],
        "entry_points": [
          "In Python, entry points must be configured manually in setup.py (console_scripts).",
          "In C++, executables must be registered in CMakeLists.txt."
        ]
      },
      "solution": {
        "auto_sourcing": "The framework wraps all sourcing automatically in the CLI. Running `framework build` will internally source ROS 2, workspace, and install/setup.* scripts depending on shell. Users never need to call `source` manually.",
        "symlink_install": "The framework always runs `colcon build --symlink-install` under the hood for fast iteration. Users don’t need to remember flags.",
        "entry_point_autogen": "When a new node is created, the CLI automatically injects the correct entry point (Python console_scripts or C++ add_executable + install targets).",
        "unified_runner": "Instead of `ros2 run pkg node`, users call `framework run <node_name>`. The CLI resolves the executable path and ensures environment variables are sourced before execution.",
        "cross_shell_support": "The CLI detects the user’s shell (bash, zsh, PowerShell) and ensures the correct setup.* script is sourced."
      },
      "why_this_matters": "Removes one of the most common beginner and intermediate frustrations. Developers can focus on building nodes and packages without worrying about sourcing or broken environments.",
      "compatibility_rule": "Generated entry points and setup scripts remain fully compatible with colcon/ros2 run. Users can still run nodes the 'ROS 2 way' if they prefer."
    }
  },
  {
    "pain_point": "Steep Learning Curve and Fragmented Ecosystem",
    "concept": "Newcomers must learn many tools, each with different syntax and quirks.",
    "details": {
      "issue": "Developers are overwhelmed by colcon, rosdep, launch files, rqt tools, etc., with no single unified entrypoint.",
      "solution": "A single CLI wraps all essentials (create, build, run, debug, deploy) under one consistent interface, reducing the learning curve and providing a Laravel-like 'happy path'.",
      "compatibility_rule": "The CLI wraps ros2 commands instead of replacing them, so developers can still fall back to raw ROS 2 commands at any time."
    }
  },
  {
    "pain_point": "Dependency and API Instability",
    "concept": "Framework churn makes projects brittle over time.",
    "details": {
      "issue": "ROS 2’s rolling release model and API changes force rewrites and constant porting.",
      "solution": "While this can’t be solved entirely, the abstraction layer can provide stability by wrapping APIs and managing dependencies in a consistent interface.",
      "compatibility_rule": "Abstractions wrap but never block access to raw ROS 2 APIs, so advanced users can bypass the framework when necessary."
    }
  },
  {
    "pain_point": "Poor Debugging and Diagnostics",
    "concept": "Debugging requires too many fragmented tools and manual inspection.",
    "details": {
      "issue": "Developers rely on ros2 topic echo, rqt_plot, ros2 doctor, each with different syntax and limited integration.",
      "solution": "The unified CLI aggregates diagnostics into a single interface (e.g., `framework debug`) that provides echo, visualization, and health checks together.",
      "compatibility_rule": "Diagnostics still use standard ROS 2 tools under the hood; developers can run them independently if preferred."
    }
  },
  {
    "pain_point": "Cross-Platform and Deployment Issues",
    "concept": "Setup and deployment are inconsistent across dev, sim, and hardware environments.",
    "details": {
      "issue": "Installing ROS 2 on Windows, Linux, macOS, or embedded devices requires manual platform-specific setup and troubleshooting.",
      "solution": "Provide one-command setup scripts and containerized environments (Docker/Podman) to ensure reproducible cross-platform development and easy deployment.",
      "compatibility_rule": "Generated environments always maintain compatibility with native ROS 2 installs (e.g., Docker containers mirror real ROS 2 setups)."
    }
  },
  {
    "pain_point": "Testing & CI/CD Integration",
    "concept": "Testing and continuous integration in ROS 2 is fragmented and difficult to standardize.",
    "details": {
      "issue": "ROS 2 testing is scattered (ament_cmake, pytest, manual rostests). CI/CD pipelines require custom YAML for GitHub Actions, GitLab, etc.",
      "solution": {
        "framework_test": "`framework test` runs both Python and C++ tests under a unified runner.",
        "ci_cd_templates": "Built-in CI/CD templates (.github/workflows/ros.yml) are auto-generated when creating a project.",
        "auto_test_nodes": "Test nodes are auto-registered in tests/ so they can run in sim or hardware with no extra setup."
      },
      "why_this_matters": "Makes testing first-class and continuous integration frictionless, ensuring teams can maintain quality without reinventing workflows.",
      "compatibility_rule": "Tests remain standard ROS 2 tests (pytest, ament_cmake) so they can be run with `colcon test` as well."
    }
  },
  {
    "reference": "Workspace Structure",
    "concept": "Default project layout that stays compatible with ROS 2 but optimized for the framework.",
    "details": {
      "layout": {
        "workspace_root": {
          "src/": "Contains all ROS 2 packages (C++ and Python).",
          "framework_core/": "Installed automatically with the CLI; contains decorators, helper libraries, and codegen utilities.",
          "launch/": "Auto-generated and user-defined launch files. New nodes/packages are auto-registered here.",
          "config/": "YAML configs for parameters, wiring, and environment settings.",
          "sim/": {
            "worlds/": "Gazebo or Ignition worlds for simulation.",
            "models/": "URDFs, meshes, and robot descriptions."
          },
          "tests/": "Unit and integration tests.",
          "scripts/": "Helper scripts and utilities (wrappers around ros2 CLI commands).",
          "tools/": "Dev and debug utilities (loggers, visualizers, etc.)."
        }
      },
      "design_reasoning": "This structure keeps src/ as the main ROS 2 workspace (so colcon builds still work). The framework_core ships with the CLI (not user-edited). Auto-registration ties new packages/nodes into launch/ and config/ automatically. Sim and tests are aggregated but under-the-hood still call ros2 CLI commands.",
      "compatibility_rule": "The src/ folder remains a valid colcon workspace at all times."
    }
  },
  {
    "reference": "CLI Commands",
    "concept": "Unified CLI that wraps and simplifies ROS 2 commands.",
    "details": {
      "commands": {
        "new_project": {
          "syntax": "genesys new <project_name>",
          "ros2_under_the_hood": "Initializes a colcon-compatible workspace and auto-creates base folders.",
          "description": "Creates a new workspace with src/, config/, launch/, sim/, and framework_core pre-installed.",
          "compatibility_rule": "Generated workspace can be built directly with colcon."
        },
        "new_package": {
          "syntax": "genesys make:pkg <package_name>",
          "interactive": "Prompts user to choose build language (Python/C++), add dependencies, and configure package type (node, library, etc.).",
          "flags": ["--with-node"],
          "ros2_under_the_hood": "Runs ros2 pkg create with flags, auto-fills package.xml, CMakeLists.txt/setup.py, and registers dependencies.",
          "description": "Creates a new package with decorators and auto-registration ready. Optionally generates an initial node if --with-node is used.",
          "compatibility_rule": "Packages follow normal ROS 2 conventions and work with ros2 pkg tools."
        },
        "new_node": {
          "syntax": "genesys make:node <node_name> --pkg <pkg_name>",
          "ros2_under_the_hood": "Creates a Python/C++ node file inside the specified package, adds it to entry points (setup.py or CMakeLists.txt), and registers it in launch/config automatically.",
          "description": "Allows users to add new nodes to an existing package without manually editing build or launch files.",
          "compatibility_rule": "Nodes are installed as standard executables or entry points."
        },
        "build": {
          "syntax": "genesys build",
          "ros2_under_the_hood": "Runs colcon build --symlink-install and sources setup.bash automatically.",
          "description": "Builds all packages with symlink-install enabled for fast iteration. No manual sourcing required.",
          "compatibility_rule": "colcon build can still be run manually if desired."
        },
        "run": {
          "syntax": "genesys run <node_name>",
          "ros2_under_the_hood": "Resolves node from launch/auto-gen files and executes ros2 run under the hood.",
          "description": "Runs a node by name without requiring manual ros2 run syntax.",
          "compatibility_rule": "Underlying ros2 run commands still work."
        },
        "sim": {
          "syntax": "genesys sim launch <world>",
          "ros2_under_the_hood": "Wraps ros2 launch with pre-configured Gazebo/Igntion integration.",
          "description": "Launches a simulation world with auto-registered robots and nodes.",
          "compatibility_rule": "Still produces valid ros2 launch files runnable independently."
        },
        "debug": {
          "syntax": "genesys debug",
          "ros2_under_the_hood": "Aggregates ros2 topic echo, ros2 doctor, rqt_plot, and logs.",
          "description": "Provides a unified dashboard for diagnostics.",
          "compatibility_rule": "Uses unmodified ROS 2 tools underneath."
        },
        "deploy": {
          "syntax": "genesys deploy <target>",
          "ros2_under_the_hood": "Runs containerized builds or SSH-based deployment scripts.",
          "description": "Deploys a project to hardware, sim, or cloud in one step.",
          "compatibility_rule": "Deployment artifacts still contain valid ROS 2 workspaces."
        },
        "test": {
          "syntax": "genesys test",
          "ros2_under_the_hood": "Runs both Python (pytest) and C++ (ament_cmake/colcon test) suites in one command.",
          "description": "Executes all tests under a unified runner with CI/CD integration hooks.",
          "compatibility_rule": "Underlying tests are still standard colcon-compatible tests."
        }
      },
      "design_reasoning": "All commands map directly to ros2 equivalents (so compatibility is never broken), but provide developer-friendly defaults, interactivity, and automation."
    }
  },
  {
    "reference": "Auto-Registration",
    "concept": "Nodes and packages are auto-wired into the framework when created.",
    "details": {
      "mechanism": {
        "decorator_scan": "The CLI scans for @node-decorated classes or functions in src/ and registers them as launchable executables.",
        "yaml_merge": "YAML config is auto-updated with new nodes, parameters, and topic wiring.",
        "launch_update": "Launch files in launch/ are regenerated or appended to include new nodes.",
        "executables": "C++ executables are added to CMakeLists.txt, Python entry points added to setup.py."
      },
      "why_this_matters": "Removes the manual step of editing multiple files (launch, CMakeLists, setup.py, YAML) whenever a node is added, reducing boilerplate and errors.",
      "compatibility_rule": "Generated launch and config files are valid ROS 2 artifacts that can be used independently of the CLI."
    }
  },
  {
    "reference": "Happy Path Workflow",
    "concept": "Step-by-step developer workflow showing commands, file outputs, and auto-generated artifacts.",
    "details": {
      "example": [
        {
          "step": "Create new workspace",
          "command": "genesys new my_robot_ws",
          "outputs": [
            "my_robot_ws/src/",
            "my_robot_ws/config/",
            "my_robot_ws/launch/",
            "my_robot_ws/sim/",
            "my_robot_ws/framework_core/"
          ]
        },
        {
          "step": "Create a package with a node",
          "command": "cd my_robot_ws && genesys make:pkg demo_pkg --with-node",
          "outputs": [
            "src/demo_pkg/package.xml",
            "src/demo_pkg/setup.py (Python) or CMakeLists.txt (C++)",
            "src/demo_pkg/demo_node.py (Python) or demo_node.cpp (C++)",
            "launch/demo_pkg_launch.py auto-generated",
            "config/demo_pkg.yaml auto-generated"
          ]
        },
        {
          "step": "Build project",
          "command": "genesys build",
          "outputs": [
            "colcon build --symlink-install executed",
            "setup.bash sourced automatically",
            "demo_node registered as an executable"
          ]
        },
        {
          "step": "Run node",
          "command": "genesys run demo_node",
          "outputs": [
            "CLI resolves node from auto-generated launch file",
            "Underlying command: ros2 run demo_pkg demo_node"
          ]
        }
      ],
      "naming_conventions": {
        "packages": "lowercase, no underscores",
        "nodes": "lowercase with underscores allowed",
        "launch_files": "<pkg_name>_launch.py",
        "config_files": "config/<pkg_name>.yaml"
      },
      "compatibility_rule": "Every artifact (package.xml, launch.py, config.yaml, setup.py, CMakeLists.txt) is still valid in plain ROS 2."
    }
  }
]
